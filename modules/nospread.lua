local engineSpread = {
	[0] = { -0.492036, 0.286111 },
	{ -0.492036, 0.286111 },
	{ -0.255320, 0.128480 },
	{ 0.456165, 0.356030 },
	{ -0.361731, 0.406344 },
	{ -0.146730, 0.834589 },
	{ -0.253288, -0.421936 },
	{ -0.448694, 0.111650 },
	{ -0.880700, 0.904610 },
	{ -0.379932, 0.138833 },
	{ 0.502579, -0.494285 },
	{ -0.263847, -0.594805 },
	{ 0.818612, 0.090368 },
	{ -0.063552, 0.044356 },
	{ 0.490455, 0.304820 },
	{ -0.192024, 0.195162 },
	{ -0.139421, 0.857106 },
	{ 0.715745, 0.336956 },
	{ -0.150103, -0.044842 },
	{ -0.176531, 0.275787 },
	{ 0.155707, -0.152178 },
	{ -0.136486, -0.591896 },
	{ -0.021022, -0.761979 },
	{ -0.166004, -0.733964 },
	{ -0.102439, -0.132059 },
	{ -0.607531, -0.249979 },
	{ -0.500855, -0.185902 },
	{ -0.080884, 0.516556 },
	{ -0.003334, 0.138612 },
	{ -0.546388, -0.000115 },
	{ -0.228092, -0.018492 },
	{ 0.542539, 0.543196 },
	{ -0.355162, 0.197473 },
	{ -0.041726, -0.015735 },
	{ -0.713230, -0.551701 },
	{ -0.045056, 0.090208 },
	{ 0.061028, 0.417744 },
	{ -0.171149, -0.048811 },
	{ 0.241499, 0.164562 },
	{ -0.129817, -0.111200 },
	{ 0.007366, 0.091429 },
	{ -0.079268, -0.008285 },
	{ 0.010982, -0.074707 },
	{ -0.517782, -0.682470 },
	{ -0.663822, -0.024972 },
	{ 0.058213, -0.078307 },
	{ -0.302041, -0.132280 },
	{ 0.217689, -0.209309 },
	{ -0.143615, 0.830349 },
	{ 0.270912, 0.071245 },
	{ -0.258170, -0.598358 },
	{ 0.099164, -0.257525 },
	{ -0.214676, -0.595918 },
	{ -0.427053, -0.523764 },
	{ -0.585472, 0.088522 },
	{ 0.564305, -0.533822 },
	{ -0.387545, -0.422206 },
	{ 0.690505, -0.299197 },
	{ 0.475553, 0.169785 },
	{ 0.347436, 0.575364 },
	{ -0.069555, -0.103340 },
	{ 0.286197, -0.618916 },
	{ -0.505259, 0.106581 },
	{ -0.420214, -0.714843 },
	{ 0.032596, -0.401891 },
	{ -0.238702, -0.087387 },
	{ 0.714358, 0.197811 },
	{ 0.208960, 0.319015 },
	{ -0.361140, 0.222130 },
	{ -0.133284, -0.492274 },
	{ 0.022824, -0.133955 },
	{ -0.100850, 0.271962 },
	{ -0.050582, -0.319538 },
	{ 0.577980, 0.095507 },
	{ 0.224871, 0.242213 },
	{ -0.628274, 0.097248 },
	{ 0.184266, 0.091959 },
	{ -0.036716, 0.474259 },
	{ -0.502566, -0.279520 },
	{ -0.073201, -0.036658 },
	{ 0.339952, -0.293667 },
	{ 0.042811, 0.130387 },
	{ 0.125881, 0.007040 },
	{ 0.138374, -0.418355 },
	{ 0.261396, -0.392697 },
	{ -0.453318, -0.039618 },
	{ 0.890159, -0.335165 },
	{ 0.466437, -0.207762 },
	{ 0.593253, 0.418018 },
	{ 0.566934, -0.643837 },
	{ 0.150918, 0.639588 },
	{ 0.150112, 0.215963 },
	{ -0.130520, 0.324801 },
	{ -0.369819, -0.019127 },
	{ -0.038889, -0.650789 },
	{ 0.490519, -0.065375 },
	{ -0.305940, 0.454759 },
	{ -0.521967, -0.550004 },
	{ -0.040366, 0.683259 },
	{ 0.137676, -0.376445 },
	{ 0.839301, 0.085979 },
	{ -0.319140, 0.481838 },
	{ 0.201437, -0.033135 },
	{ 0.384637, -0.036685 },
	{ 0.598419, 0.144371 },
	{ -0.061424, -0.608645 },
	{ -0.065337, 0.308992 },
	{ -0.029356, -0.634337 },
	{ 0.326532, 0.047639 },
	{ 0.505681, -0.067187 },
	{ 0.691612, 0.629364 },
	{ -0.038588, -0.635947 },
	{ 0.637837, -0.011815 },
	{ 0.765338, 0.563945 },
	{ 0.213416, 0.068664 },
	{ -0.576581, 0.554824 },
	{ 0.246580, 0.132726 },
	{ 0.385548, -0.070054 },
	{ 0.538735, -0.291010 },
	{ 0.609944, 0.590973 },
	{ -0.463240, 0.010302 },
	{ -0.047718, 0.741086 },
	{ 0.308590, -0.322179 },
	{ -0.291173, 0.256367 },
	{ 0.287413, -0.510402 },
	{ 0.864716, 0.158126 },
	{ 0.572344, 0.561319 },
	{ -0.090544, 0.332633 },
	{ 0.644714, 0.196736 },
	{ -0.204198, 0.603049 },
	{ -0.504277, -0.641931 },
	{ 0.218554, 0.343778 },
	{ 0.466971, 0.217517 },
	{ -0.400880, -0.299746 },
	{ -0.582451, 0.591832 },
	{ 0.421843, 0.118453 },
	{ -0.215617, -0.037630 },
	{ 0.341048, -0.283902 },
	{ -0.246495, -0.138214 },
	{ 0.214287, -0.196102 },
	{ 0.809797, -0.498168 },
	{ -0.115958, -0.260677 },
	{ -0.025448, 0.043173 },
	{ -0.416803, -0.180813 },
	{ -0.782066, 0.335273 },
	{ 0.192178, -0.151171 },
	{ 0.109733, 0.165085 },
	{ -0.617935, -0.274392 },
	{ 0.283301, 0.171837 },
	{ -0.150202, 0.048709 },
	{ -0.179954, -0.288559 },
	{ -0.288267, -0.134894 },
	{ -0.049203, 0.231717 },
	{ -0.065761, 0.495457 },
	{ 0.082018, -0.457869 },
	{ -0.159553, 0.032173 },
	{ 0.508305, -0.090690 },
	{ 0.232269, -0.338245 },
	{ -0.374490, -0.480945 },
	{ -0.541244, 0.194144 },
	{ -0.040063, -0.073532 },
	{ 0.136516, -0.167617 },
	{ -0.237350, 0.456912 },
	{ -0.446604, -0.494381 },
	{ 0.078626, -0.020068 },
	{ 0.163208, 0.600330 },
	{ -0.886186, -0.345326 },
	{ -0.732948, -0.689349 },
	{ 0.460564, -0.719006 },
	{ -0.033688, -0.333340 },
	{ -0.325414, -0.111704 },
	{ 0.010928, 0.723791 },
	{ 0.713581, -0.077733 },
	{ -0.050912, -0.444684 },
	{ -0.268509, 0.381144 },
	{ -0.175387, 0.147070 },
	{ -0.429779, 0.144737 },
	{ -0.054564, 0.821354 },
	{ 0.003205, 0.178130 },
	{ -0.552814, 0.199046 },
	{ 0.225919, -0.195013 },
	{ 0.056040, -0.393974 },
	{ -0.505988, 0.075184 },
	{ -0.510223, 0.156271 },
	{ -0.209616, 0.111174 },
	{ -0.605132, -0.117104 },
	{ 0.412433, -0.035510 },
	{ -0.573947, -0.691295 },
	{ -0.712686, 0.021719 },
	{ -0.643297, 0.145307 },
	{ 0.245038, 0.343062 },
	{ -0.235623, -0.159307 },
	{ -0.834004, 0.088725 },
	{ 0.121377, 0.671713 },
	{ 0.528614, 0.607035 },
	{ -0.285699, -0.111312 },
	{ 0.603385, 0.401094 },
	{ 0.632098, -0.439659 },
	{ 0.681016, -0.242436 },
	{ -0.261709, 0.304265 },
	{ -0.653737, -0.199245 },
	{ -0.435512, -0.762978 },
	{ 0.701105, 0.389527 },
	{ 0.093495, -0.148484 },
	{ 0.715218, 0.638291 },
	{ -0.055431, -0.085173 },
	{ -0.727438, 0.889783 },
	{ -0.007230, -0.519183 },
	{ -0.359615, 0.058657 },
	{ 0.294681, 0.601155 },
	{ 0.226879, -0.255430 },
	{ -0.307847, -0.617373 },
	{ 0.340916, -0.780086 },
	{ -0.028277, 0.610455 },
	{ -0.365067, 0.323311 },
	{ 0.001059, -0.270451 },
	{ 0.304025, 0.047478 },
	{ 0.297389, 0.383859 },
	{ 0.288059, 0.262816 },
	{ -0.889315, 0.533731 },
	{ 0.215887, 0.678889 },
	{ 0.287135, 0.343899 },
	{ 0.423951, 0.672285 },
	{ 0.411912, -0.812886 },
	{ 0.081615, -0.497358 },
	{ -0.051963, -0.117891 },
	{ -0.062387, 0.331698 },
	{ 0.020458, -0.734125 },
	{ -0.160176, 0.196321 },
	{ 0.044898, -0.024032 },
	{ -0.153162, 0.930951 },
	{ -0.015084, 0.233476 },
	{ 0.395043, 0.645227 },
	{ -0.232095, 0.283834 },
	{ -0.507699, 0.317122 },
	{ -0.606604, -0.227259 },
	{ 0.526430, -0.408765 },
	{ 0.304079, 0.135680 },
	{ -0.134042, 0.508741 },
	{ -0.276770, 0.383958 },
	{ -0.298963, -0.233668 },
	{ 0.171889, 0.697367 },
	{ -0.292571, -0.317604 },
	{ 0.587806, 0.115584 },
	{ -0.346690, -0.098320 },
	{ 0.956701, -0.040982 },
	{ 0.040838, 0.595304 },
	{ 0.365201, -0.519547 },
	{ -0.397271, -0.090567 },
	{ -0.124873, -0.356800 },
	{ -0.122144, 0.617725 },
	{ 0.191266, -0.197764 },
	{ -0.178092, 0.503667 },
	{ 0.103221, 0.547538 },
	{ 0.019524, 0.621226 },
	{ 0.663918, -0.573476 }
}

Const = {
	0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee,
	0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501,
	0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be,
	0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821,
	0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa,
	0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8,
	0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed,
	0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a,
	0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c,
	0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70,
	0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05,
	0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665,
	0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039,
	0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1,
	0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1,
	0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391,
	0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476
}

local f = function (x,y,z) return bit.bor(bit.band(x,y),bit.band(-x-1,z)) end
local g = function (x,y,z) return bit.bor(bit.band(x,z),bit.band(y,-z-1)) end
local h = function (x,y,z) return bit.bxor(x,bit.bxor(y,z)) end
local i = function (x,y,z) return bit.bxor(y,bit.bor(x,-z-1)) end

MD5 = {}

function MD5.z( f, a, b, c, d, x, s, ac )
	a = bit.band( a + f( b, c, d ) + x + ac, 0xffffffff )
	return bit.bor( bit.lshift( bit.band( a, bit.rshift( 0xffffffff, s )), s ), bit.rshift( a, 32 - s )) + b
end

function MD5.Fix( a )
	if ( a > 2 ^ 31 ) then
		return a - 2 ^ 32
	end
	return a
end

function MD5.Transform( A, B, C, D, X ) -- theres gotta be a better way to do this
	local a, b, c, d = A, B, C, D

	a = MD5.z( f, a, b, c, d, X[0], 7, Const[1] )
	a = MD5.Fix( a ) b = MD5.Fix( b ) c = MD5.Fix( c ) d = MD5.Fix( d )
	d = MD5.z( f, d, a, b, c, X[1], 12, Const[2] )
	a = MD5.Fix( a ) b = MD5.Fix( b ) c = MD5.Fix( c ) d = MD5.Fix( d )
	c = MD5.z( f, c, d, a, b, X[2], 17, Const[3] )
	a = MD5.Fix( a ) b = MD5.Fix( b ) c = MD5.Fix( c ) d = MD5.Fix( d )
	b = MD5.z( f, b, c, d, a, X[3], 22, Const[4] )
	a = MD5.Fix( a ) b = MD5.Fix( b ) c = MD5.Fix( c ) d = MD5.Fix( d )
	a = MD5.z( f, a, b, c, d, X[4], 7, Const[5] )
	a = MD5.Fix( a ) b = MD5.Fix( b ) c = MD5.Fix( c ) d = MD5.Fix( d )
	d = MD5.z( f, d, a, b, c, X[5], 12, Const[6] )
	a = MD5.Fix( a ) b = MD5.Fix( b ) c = MD5.Fix( c ) d = MD5.Fix( d )
	c = MD5.z( f, c, d, a, b, X[6], 17, Const[7] )
	a = MD5.Fix( a ) b = MD5.Fix( b ) c = MD5.Fix( c ) d = MD5.Fix( d )
	b = MD5.z( f, b, c, d, a, X[7], 22, Const[8] )
	a = MD5.Fix( a ) b = MD5.Fix( b ) c = MD5.Fix( c ) d = MD5.Fix( d )
	a = MD5.z( f, a, b, c, d, X[8], 7, Const[9] )
	a = MD5.Fix( a ) b = MD5.Fix( b ) c = MD5.Fix( c ) d = MD5.Fix( d )
	d = MD5.z( f, d, a, b, c, X[9], 12, Const[ 10 ] )
	a = MD5.Fix( a ) b = MD5.Fix( b ) c = MD5.Fix( c ) d = MD5.Fix( d )
	c = MD5.z( f, c, d, a, b, X[10], 17, Const[11] )
	a = MD5.Fix( a ) b = MD5.Fix( b ) c = MD5.Fix( c ) d = MD5.Fix( d )
	b = MD5.z( f, b, c, d, a, X[11], 22, Const[12] )
	a = MD5.Fix( a ) b = MD5.Fix( b ) c = MD5.Fix( c ) d = MD5.Fix( d )
	a = MD5.z( f, a, b, c, d, X[12], 7, Const[13] )
	a = MD5.Fix( a ) b = MD5.Fix( b ) c = MD5.Fix( c ) d = MD5.Fix( d )
	d = MD5.z( f, d, a, b, c, X[13], 12, Const[14] )
	a = MD5.Fix( a ) b = MD5.Fix( b ) c = MD5.Fix( c ) d = MD5.Fix( d )
	c = MD5.z( f, c, d, a, b, X[14], 17, Const[15] )
	a = MD5.Fix( a ) b = MD5.Fix( b ) c = MD5.Fix( c ) d = MD5.Fix( d )
	b = MD5.z( f, b, c, d, a, X[15], 22, Const[16] )
	a = MD5.Fix( a ) b = MD5.Fix( b ) c = MD5.Fix( c ) d = MD5.Fix( d )

	a = MD5.z( g, a, b, c, d, X[1], 5, Const[17] )
	a = MD5.Fix( a ) b = MD5.Fix( b ) c = MD5.Fix( c ) d = MD5.Fix( d )
	d = MD5.z( g, d, a, b, c, X[6], 9, Const[18] )
	a = MD5.Fix( a ) b = MD5.Fix( b ) c = MD5.Fix( c ) d = MD5.Fix( d )
	c = MD5.z( g, c, d, a, b, X[11], 14, Const[19] )
	a = MD5.Fix( a ) b = MD5.Fix( b ) c = MD5.Fix( c ) d = MD5.Fix( d )
	b = MD5.z( g, b, c, d, a, X[0], 20, Const[20] )
	a = MD5.Fix( a ) b = MD5.Fix( b ) c = MD5.Fix( c ) d = MD5.Fix( d )
	a = MD5.z( g, a, b, c, d, X[5], 5, Const[21] )
	a = MD5.Fix( a ) b = MD5.Fix( b ) c = MD5.Fix( c ) d = MD5.Fix( d )
	d = MD5.z( g, d, a, b, c, X[10], 9, Const[22] )
	a = MD5.Fix( a ) b = MD5.Fix( b ) c = MD5.Fix( c ) d = MD5.Fix( d )
	c = MD5.z( g, c, d, a, b, X[15], 14, Const[23] )
	a = MD5.Fix( a ) b = MD5.Fix( b ) c = MD5.Fix( c ) d = MD5.Fix( d )
	b = MD5.z( g, b, c, d, a, X[4], 20, Const[24] )
	a = MD5.Fix( a ) b = MD5.Fix( b ) c = MD5.Fix( c ) d = MD5.Fix( d )
	a = MD5.z( g, a, b, c, d, X[9], 5, Const[25] )
	a = MD5.Fix( a ) b = MD5.Fix( b ) c = MD5.Fix( c ) d = MD5.Fix( d )
	d = MD5.z( g, d, a, b, c, X[14], 9, Const[26] )
	a = MD5.Fix( a ) b = MD5.Fix( b ) c = MD5.Fix( c ) d = MD5.Fix( d )
	c = MD5.z( g, c, d, a, b, X[3], 14, Const[27] )
	a = MD5.Fix( a ) b = MD5.Fix( b ) c = MD5.Fix( c ) d = MD5.Fix( d )
	b = MD5.z( g, b, c, d, a, X[8], 20, Const[28] )
	a = MD5.Fix( a ) b = MD5.Fix( b ) c = MD5.Fix( c ) d = MD5.Fix( d )
	a = MD5.z( g, a, b, c, d, X[13], 5, Const[29] )
	a = MD5.Fix( a ) b = MD5.Fix( b ) c = MD5.Fix( c ) d = MD5.Fix( d )
	d = MD5.z( g, d, a, b, c, X[2], 9, Const[30] )
	a = MD5.Fix( a ) b = MD5.Fix( b ) c = MD5.Fix( c ) d = MD5.Fix( d )
	c = MD5.z( g, c, d, a, b, X[7], 14, Const[31] )
	a = MD5.Fix( a ) b = MD5.Fix( b ) c = MD5.Fix( c ) d = MD5.Fix( d )
	b = MD5.z( g, b, c, d, a, X[12], 20, Const[32] )
	a = MD5.Fix( a ) b = MD5.Fix( b ) c = MD5.Fix( c ) d = MD5.Fix( d )

	a = MD5.z( h, a, b, c, d, X[5], 4, Const[33] )
	a = MD5.Fix( a ) b = MD5.Fix( b ) c = MD5.Fix( c ) d = MD5.Fix( d )
	d = MD5.z( h, d, a, b, c, X[8], 11, Const[34] )
	a = MD5.Fix( a ) b = MD5.Fix( b ) c = MD5.Fix( c ) d = MD5.Fix( d )
	c = MD5.z( h, c, d, a, b, X[11], 16, Const[35] )
	a = MD5.Fix( a ) b = MD5.Fix( b ) c = MD5.Fix( c ) d = MD5.Fix( d )
	b = MD5.z( h, b, c, d, a, X[14], 23, Const[36] )
	a = MD5.Fix( a ) b = MD5.Fix( b ) c = MD5.Fix( c ) d = MD5.Fix( d )
	a = MD5.z( h, a, b, c, d, X[1], 4, Const[37] )
	a = MD5.Fix( a ) b = MD5.Fix( b ) c = MD5.Fix( c ) d = MD5.Fix( d )
	d = MD5.z( h, d, a, b, c, X[4], 11, Const[38] )
	a = MD5.Fix( a ) b = MD5.Fix( b ) c = MD5.Fix( c ) d = MD5.Fix( d )
	c = MD5.z( h, c, d, a, b, X[7], 16, Const[39] )
	a = MD5.Fix( a ) b = MD5.Fix( b ) c = MD5.Fix( c ) d = MD5.Fix( d )
	b = MD5.z( h, b, c, d, a, X[10], 23, Const[40] )
	a = MD5.Fix( a ) b = MD5.Fix( b ) c = MD5.Fix( c ) d = MD5.Fix( d )
	a = MD5.z( h, a, b, c, d, X[13], 4, Const[41] )
	a = MD5.Fix( a ) b = MD5.Fix( b ) c = MD5.Fix( c ) d = MD5.Fix( d )
	d = MD5.z( h, d, a, b, c, X[0], 11, Const[42] )
	a = MD5.Fix( a ) b = MD5.Fix( b ) c = MD5.Fix( c ) d = MD5.Fix( d )
	c = MD5.z( h, c, d, a, b, X[3], 16, Const[43] )
	a = MD5.Fix( a ) b = MD5.Fix( b ) c = MD5.Fix( c ) d = MD5.Fix( d )
	b = MD5.z( h, b, c, d, a, X[6], 23, Const[44] )
	a = MD5.Fix( a ) b = MD5.Fix( b ) c = MD5.Fix( c ) d = MD5.Fix( d )
	a = MD5.z( h, a, b, c, d, X[9], 4, Const[45] )
	a = MD5.Fix( a ) b = MD5.Fix( b ) c = MD5.Fix( c ) d = MD5.Fix( d )
	d = MD5.z( h, d, a, b, c, X[12], 11, Const[46] )
	a = MD5.Fix( a ) b = MD5.Fix( b ) c = MD5.Fix( c ) d = MD5.Fix( d )
	c = MD5.z( h, c, d, a, b, X[15], 16, Const[47] )
	a = MD5.Fix( a ) b = MD5.Fix( b ) c = MD5.Fix( c ) d = MD5.Fix( d )
	b = MD5.z( h, b, c, d, a, X[2], 23, Const[48] )
	a = MD5.Fix( a ) b = MD5.Fix( b ) c = MD5.Fix( c ) d = MD5.Fix( d )

	a = MD5.z( i, a, b, c, d, X[0], 6, Const[49] )
	a = MD5.Fix( a ) b = MD5.Fix( b ) c = MD5.Fix( c ) d = MD5.Fix( d )
	d = MD5.z( i, d, a, b, c, X[7], 10, Const[50] )
	a = MD5.Fix( a ) b = MD5.Fix( b ) c = MD5.Fix( c ) d = MD5.Fix( d )
	c = MD5.z( i ,c, d, a, b, X[14], 15, Const[51] )
	a = MD5.Fix( a ) b = MD5.Fix( b ) c = MD5.Fix( c ) d = MD5.Fix( d )
	b = MD5.z( i, b, c, d, a, X[5], 21, Const[52] )
	a = MD5.Fix( a ) b = MD5.Fix( b ) c = MD5.Fix( c ) d = MD5.Fix( d )
	a = MD5.z( i, a, b, c, d, X[12], 6, Const[53] )
	a = MD5.Fix( a ) b = MD5.Fix( b ) c = MD5.Fix( c ) d = MD5.Fix( d )
	d = MD5.z( i, d, a, b, c, X[3], 10, Const[54] )
	a = MD5.Fix( a ) b = MD5.Fix( b ) c = MD5.Fix( c ) d = MD5.Fix( d )
	c = MD5.z( i, c, d, a, b, X[10], 15, Const[55] )
	a = MD5.Fix( a ) b = MD5.Fix( b ) c = MD5.Fix( c ) d = MD5.Fix( d )
	b = MD5.z( i, b, c, d, a, X[1], 21, Const[56] )
	a = MD5.Fix( a ) b = MD5.Fix( b ) c = MD5.Fix( c ) d = MD5.Fix( d )
	a = MD5.z( i, a, b, c, d, X[8], 6, Const[57] )
	a = MD5.Fix( a ) b = MD5.Fix( b ) c = MD5.Fix( c ) d = MD5.Fix( d )
	d = MD5.z( i, d, a, b, c, X[15], 10, Const[58] )
	a = MD5.Fix( a ) b = MD5.Fix( b ) c = MD5.Fix( c ) d = MD5.Fix( d )
	c = MD5.z ( i, c, d, a, b, X[6], 15, Const[59] )
	a = MD5.Fix( a ) b = MD5.Fix( b ) c = MD5.Fix( c ) d = MD5.Fix( d )
	b = MD5.z( i, b, c, d, a, X[13], 21, Const[60] )
	a = MD5.Fix( a ) b = MD5.Fix( b ) c = MD5.Fix( c ) d = MD5.Fix( d )
	a = MD5.z( i, a, b, c, d, X[4], 6, Const[61] )
	a = MD5.Fix( a ) b = MD5.Fix( b ) c = MD5.Fix( c ) d = MD5.Fix( d )
	d = MD5.z( i, d, a, b, c, X[11], 10, Const[62] )
	a = MD5.Fix( a ) b = MD5.Fix( b ) c = MD5.Fix( c ) d = MD5.Fix( d )
	c = MD5.z( i, c, d, a, b, X[2], 15, Const[63] )
	a = MD5.Fix( a ) b = MD5.Fix( b ) c = MD5.Fix( c ) d = MD5.Fix( d )
	b = MD5.z( i, b, c, d, a, X[9], 21, Const[64] )
	a = MD5.Fix( a ) b = MD5.Fix( b ) c = MD5.Fix( c ) d = MD5.Fix( d )
	return A + a, B + b, C + c, D + d
end

function MD5.PseudoRandom( number )
	local a, b, c, d = MD5.Fix( Const[65] ), MD5.Fix( Const[66] ), MD5.Fix( Const[67] ), MD5.Fix( Const[68] )
	local m = { }

	for iter = 0, 15 do
		m[iter] = 0
	end

	m[0] = number
	m[1] = 128
	m[14] = 32
	a, b, c, d = MD5.Transform( a, b, c, d, m )
	return bit.rshift( MD5.Fix( b ), 16 ) % 256
end

function math.Rand( low, high )
	return low + ( high - low ) * math.random()
end

local function LerpCW20(val, min, max) -- basically a wrapper that limits 'val' (aka progress) to a max of 1
	val = val > 1 and 1 or val
	return Lerp(val, min, max)
end

Spread = {}
Spread["weapon_smg1"] = Vector( 0.04362, 0.04362, 0.04362 )
Spread["weapon_ar2"] = Vector( 0.02618, 0.02618, 0.02618 )
Spread["weapon_shotgun"] = Vector( 0.08716, 0.08716, 0.08716 )
Spread["weapon_pistol"] = Vector( 0.00873, 0.00873, 0.00873 )
HL2VP = {["weapon_smg1"] = true, ["weapon_ar2"] = true, ["weapon_shotgun"] = true, ["weapon_gauss"] = true}

BulletInfo = {}

local nigga = R.Entity.FireBullets

_R.Entity.FireBullets = function( ent, bul )
	local wep = R.Player.GetActiveWeapon( LocalPlayer() ) or nil
	if !IsValid( wep ) then return end
	local class = R.Entity.GetClass( wep )

	if !bul.Spread or !IsValid( wep ) or !R.Player.Alive( LocalPlayer() ) then
		return R.Entity.FireBullets( ent, bul )
	end

	if !Spread[ class ] or Spread[ class ] != bul.Spread then
		Spread[ class ] = bul.Spread
	end

	BulletInfo[ class ] = bul

	return nigga( ent, bul )
end

detour( R.Entity.FireBullets, _R.Entity.FireBullets, "_R.Entity.FireBullets" )

function math.RemapClamped( val, A, B, C, D)
	if A == B then
		return val >= B and D or C
	end

	local cVal = (val - A) / (B - A);
	cVal = math.Clamp( cVal, 0.0, 1.0 );

	return C + (D - C) * cVal;
end

local function ClipPunchAngleOffset( input, punch, clip )
	local final = input + punch

	for i = 1, 3 do
		if final[i] > clip[i] then
			final[i] = clip[i]
		elseif final[i] < -clip[i] then
			final[i] = -clip[i]
		end

		input[i] = final[i] - punch[i]
	end

	return input
end

local function DoMachineGunKick( seed, MAX_VERTICAL_KICK, m_fFireDuration, SLIDE_LIMIT )
	local KICK_MIN_X = 0.2
	local KICK_MIN_Y = 0.2
	local KICK_MIN_Z = 0.1

	local iSeed = bit.band( seed, 255 )

	local kickPerc = ( m_fFireDuration > SLIDE_LIMIT ) and SLIDE_LIMIT or m_fFireDuration
	kickPerc = kickPerc / SLIDE_LIMIT

	R.Player.ViewPunchReset( LocalPlayer(), 10 )

	local vecScratch = Angle()

	vecScratch.x = -( KICK_MIN_X + ( MAX_VERTICAL_KICK * kickPerc ) )
	vecScratch.y = -( KICK_MIN_Y + ( MAX_VERTICAL_KICK * kickPerc ) ) / 3
	vecScratch.z = KICK_MIN_Z + ( MAX_VERTICAL_KICK * kickPerc ) / 8

	setSeed( iSeed )

	if randomInt( -1, 1 ) >= 0 then
		vecScratch.y = vecScratch.y * -1;
	end

	setSeed( iSeed + 1 )

	if randomInt( -1, 1 ) >= 0 then
		vecScratch.z = vecScratch.z * -1;
	end

	vecScratch = ClipPunchAngleOffset( vecScratch, R.Player.GetViewPunchAngles(LocalPlayer()), Angle(24.0, 3.0, 1.0 ))

	return vecScratch * 0.5
end

function Aimbot.EngineSpread( cmd, cone, ang )
	local seed = MD5.PseudoRandom( R.CUserCmd.CommandNumber( cmd ))
	local x, y = engineSpread[seed][1], engineSpread[seed][2]
	local forward, right, up = R.Angle.Forward( ang ), R.Angle.Right( ang ), R.Angle.Up( ang )
	local RetVec = forward + ( x * cone[1] * right ) + ( y * cone[2] * up )
	local spreadAngles = R.Vector.Angle( RetVec )

	R.Angle.Normalize( spreadAngles )
end

function Aimbot.ArcCWShootPos( cmd, wep )
	local dir = R.CUserCmd.GetViewAngles( cmd )
	local offset = wep:GetBuff_Override("Override_BarrelOffsetHip") or wep.BarrelOffsetHip

	if wep:GetState() == __G.ArcCW.STATE_SIGHTS then
		offset = wep:GetBuff_Override("Override_BarrelOffsetSighted") or wep.BarrelOffsetSighted
	end

	local src = R.Player.GetShootPos( LocalPlayer() )

	src = src + R.Angle.Right( dir ) * offset[1]
	src = src + R.Angle.Forward( dir ) * offset[2]
	src = src + R.Angle.Up( dir ) * offset[3]

	return src
end

function Aimbot.ArcCWApplyRandomSpread(dir, spread)
	local radius = math.Rand(0, 1)
	local theta = math.Rand(0, math.rad(360))
	local bulletang = R.Vector.Angle(dir)
	local forward, right, up = bulletang:Forward(), bulletang:Right(), bulletang:Up()
	local x = radius * math.sin(theta)
	local y = radius * math.cos(theta)

	return (dir + right * spread * x + up * spread * y)
end

function Aimbot.PredictSpread( cmd, ang )
	local wep = R.Player.GetActiveWeapon( LocalPlayer() )
	if !IsValid(wep) then return ang end
	local class = R.Entity.GetClass( wep )
	local cone = Spread[ class ]

	if HL2VP[R.Entity.GetClass( wep )] then
		ang = ang - R.Player.GetViewPunchAngles(LocalPlayer())
	end

	if class == "weapon_pistol" then
		local ramp = math.RemapClamped( R.Entity.GetInternalVariable( wep, "m_flAccuracyPenalty"), 0, 1.5, 0, 1 )
		cone = LerpVector( ramp, Vector(0.00873, 0.00873, 0.00873), Vector(0.05234, 0.05234, 0.05234))
	elseif class == "weapon_pistolr" then
		local ramp = math.RemapClamped( wep:GetAccuracyPenalty(), 0, 1.5, 0, 1 )
		cone = LerpVector( ramp, Vector(0.00873, 0.00873, 0.00873), Vector(0.05234, 0.05234, 0.05234))
	elseif wep.Base == "weapon_v74_base" then
		local spreadX, spreadY = wep:GetSpread()

		math.randomseed(R.CUserCmd.CommandNumber( cmd ) % 0x7FFFFFFF)

		local t = {
			m_vecDirection = R.Angle.Forward( ang ),
			m_vecSpread = Vector(spreadX, spreadY, 0)
		}

		wep:ApplySpread(t)

		local vecSpread = t.m_vecDirection
		local angSpread = R.Vector.Angle( vecSpread )

		R.Angle.Normalize( angSpread )
		return ang * 2 - angSpread - R.Player.GetViewPunchAngles(LocalPlayer())
	elseif wep.Base == "weapon_swcs_base" then
		local iSeed = wep:GetRandomSeed()
		iSeed = iSeed + 1
		-- wep:SetRandomSeed(iSeed)

		local getVelocity = _R.Entity.GetVelocity
		_R.Entity.GetVelocity = R.Entity.GetAbsVelocity
		wep:DecayAimPunchAngle()
		wep:UpdateAccuracyPenalty()
		_R.Entity.GetVelocity = getVelocity

		local fInaccuracy = wep:GetInaccuracy()

		local rand = __G.UniformRandomStream(iSeed) -- init random system with this seed

		-- Accuracy curve density adjustment FOR R8 REVOLVER SECONDARY FIRE, NEGEV WILD BEAST
		local flRadiusCurveDensity = rand:RandomFloat()

		if wep.IsR8Revolver and wep:GetWeaponMode() == __G.Secondary_Mode then -- R8 REVOLVER SECONDARY FIRE
			flRadiusCurveDensity = 1 - (flRadiusCurveDensity * flRadiusCurveDensity)
		elseif wep.IsNegev and wep:GetRecoilIndex() < 3 then -- NEGEV WILD BEAST
			for j = 3, wep:GetRecoilIndex(), -1 do
				flRadiusCurveDensity = flRadiusCurveDensity * flRadiusCurveDensity
			end

			flRadiusCurveDensity = 1 - flRadiusCurveDensity
		end

		-- Get accuracy displacement
		local fTheta0 = rand:RandomFloat(0, 2 * math.pi)

		local fRadius0 = flRadiusCurveDensity * fInaccuracy
		local x0 = fRadius0 * math.cos(fTheta0)
		local y0 = fRadius0 * math.sin(fTheta0)

		local flSpreadCurveDensity = rand:RandomFloat()
		if wep:GetIsRevolver() and wep:GetWeaponMode() == __G.Secondary_Mode then
			flSpreadCurveDensity = 1 - (flSpreadCurveDensity * flSpreadCurveDensity)
		elseif wep.IsNegev and wep:GetRecoilIndex() < 3 then
			for j = 3, wep:GetRecoilIndex(), -1 do
				flSpreadCurveDensity = flSpreadCurveDensity * flSpreadCurveDensity
			end

			flSpreadCurveDensity = 1 - flSpreadCurveDensity
		end

		if bForceMaxInaccuracy then
			flSpreadCurveDensity = 1
		end

		local fTheta1 = rand:RandomFloat(0, 2 * math.pi)

		local fRadius1 = flSpreadCurveDensity * wep:GetSpread()
		local x1 = fRadius1 * math.cos(fTheta1)
		local y1 = fRadius1 * math.sin(fTheta1)

		local angShooting = ang + wep:GetAimPunchAngle()
		R.Angle.Normalize(angShooting)

		local vecDirShooting, vecRight, vecUp = R.Angle.Forward(angShooting), R.Angle.Right(angShooting), R.Angle.Up(angShooting)

		-- fire bullets individually to avoid getting shotguns clipped to bbox
		local xSpread, ySpread = x0 + x1, y0 + y1

		local vecDir = vecDirShooting + (xSpread * vecRight) + (ySpread * vecUp)
		R.Vector.Normalize(vecDir)

		ang = ang + (ang - R.Vector.Angle( vecDir ))
		return ang
	elseif wep.Base == "weapon_csbasegun" then

	elseif wep.Base and wep.Base == "cw_base" then -- not perfect, blame BlacK

		if !LocalPlayer().LastView then
			local curCone = wep.CurCone

			curCone = curCone * 0.4

			if !R.Entity.OnGround( LocalPlayer() ) then
				curCone = curCone * 10
			end

			math.randomseed( R.CUserCmd.CommandNumber( cmd ))

			return ang - R.Player.GetViewPunchAngles( LocalPlayer() ) - Angle(math.Rand(-curCone, curCone), math.Rand(-curCone, curCone), 0) * 25
		end

		if wep.getBaseCone then
			local vel = R.Vector.Length( R.Entity.GetVelocity( LocalPlayer() ))
			local noViewPunch = R.Angle.Forward(ang - R.Player.GetViewPunchAngles( LocalPlayer() ))
			local ViewAff = LerpCW20( engine.TickInterval() * 10, ViewAff, R.Vector.Length(noViewPunch - R.Angle.Forward(LastEyeAngle)) * 0.5 )

			local AddSpread = 0

			-- self.AddSpread = math.Clamp(self.AddSpread - 0.5 * self.AddSpreadSpeed * dt, 0, self:getMaxSpreadIncrease(maxSpreadMod))

			//local AddSpread = math.Clamp(AddSpread - 0.5 * wep.AddSpreadSpeed * dt, 0, self:getMaxSpreadIncrease(maxSpreadMod))

			local baseCone, maxSpreadMod = wep:getBaseCone()

			baseCone = baseCone + wep.AddSpread

			if R.Player.Crouching( LocalPlayer() ) then
				baseCone = baseCone * wep:getCrouchSpreadModifier()
			end

			if wep.dt.State == __G.CW_AIMING then
				baseCone = math.min(baseCone + (vel / 10000 * wep.VelocitySensitivity) * wep.AimMobilitySpreadMod, wep.HipSpread)
			else
				baseCone = baseCone + (vel / 10000 * wep.VelocitySensitivity)
			end

			if wep.ShootWhileProne and wep:isPlayerProne() then
				baseCone = baseCone + vel / 1000
			end

			baseCone = baseCone + ViewAff

			local actualCone = math.min(math.max(baseCone, 0), 0.09 + wep:getMaxSpreadIncrease(maxSpreadMod))

			math.randomseed( R.CUserCmd.CommandNumber( cmd ) )

			cone = actualCone

			if R.Player.Crouching( LocalPlayer() ) then
				cone = cone * 0.85
			end
		else -- shitty MW server
			-- local eyeAng = 
			wep:CalculateSpread( R.Vector.Length( R.Entity.GetAbsVelocity( LocalPlayer() )) )
			cone = wep.CurCone
			math.randomseed( CurTime() )
		end

		local x = math.Rand(-cone, cone)
		local y = math.Rand(-cone, cone)

		local spread = ang - R.Player.GetViewPunchAngles( LocalPlayer() ) - Angle(x, y, 0) * 25

		--print("Spread after", LerpCW20( engine.TickInterval() * 10, ViewAff, R.Vector.Length(R.Angle.Forward(spread) - R.Angle.Forward(LastEyeAngle)) * 0.5 ))

		return spread
	elseif wep.Base and wep.Base == "fas2_base" then -- WIP STILL
		local velocity = R.Vector.Length( R.Entity.GetAbsVelocity( LocalPlayer() ))
		local shootPos = R.Player.GetShootPos( LocalPlayer() )
		local newAngles = ang - R.Player.GetViewPunchAngles( LocalPlayer() )
		local addSpread = Lerp(0.25, LocalPlayer().ViewAff, R.Vector.Length(R.Angle.Forward(newAngles) - LocalPlayer().LastView) * 0.5)
		local baseCone = wep.HipCone * (R.Player.Crouching( LocalPlayer() ) and 0.75 or 1) * (wep.dt.Bipod and 0.3 or 1)

		if wep.dt.Status == __G.FAS_STAT_ADS then
			local trace = util.TraceLine({
				start = shootPos,
				endpos = shootPos + R.Angle.Forward(newAngles) * 30,
				filter = LocalPlayer()
			})

			if (!trace.Hit) then
				baseCone = wep.AimCone
			end
		end

		local baseSpread = baseCone + wep.AddSpread * (wep.dt.Bipod and 0.5 or 1)
		local accuracyPenalty = (velocity / 10000 * wep.VelocitySensitivity) * (wep.dt.Status == __G.FAS_STAT_ADS and 0.25 or 1)
		local actualCone = math.min(math.max(baseSpread + accuracyPenalty + addSpread, 0), 0.09 + wep.MaxSpreadInc )

		math.randomseed(CurTime())
		local spread = Angle(math.Rand(-actualCone, actualCone), math.Rand(-actualCone, actualCone), 0) * 25

		return ang - (R.Player.GetViewPunchAngles( LocalPlayer() ) + spread)
	-- elseif wep.IsTFAWeapon then -- NOT 100% PERFECT, BUT REDUCES SPREAD BY AROUND 70-90%
	-- 	local tfa_cone = wep:CalculateConeRecoil()
	-- 	cone = Vector( tfa_cone, tfa_cone, 0 )

	-- 	ang = ang - R.Player.GetViewPunchAngles( LocalPlayer() )
	elseif wep.IsTFAWeapon then -- new TFA base shit thanks to me and BlacK
		local con, rec = wep:CalculateConeRecoil()
		local dYaw, dPitch = wep:ComputeBulletDeviation(1, 1, con)
		local up, right = ang:Up(), ang:Right()

		local after_recoil = Angle(ang.p, ang.y, 0)

		after_recoil:RotateAroundAxis(up, dYaw)
		after_recoil:RotateAroundAxis(right, dPitch)

		after_recoil.p = after_recoil.p + wep:GetViewPunchP()
		after_recoil.y = after_recoil.y + wep:GetViewPunchY()

		return ang + (ang - after_recoil)
	elseif wep.Base == "arccw_base" then
		local disp = wep:GetDispersion() * __G.ArcCW.MOAToAcc / 10
		local spread = __G.ArcCW.MOAToAcc * wep:GetBuff("AccuracyMOA")

		math.randomseed(math.Round(__G.util.SharedRandom(wep:GetBurstCount(), -1337, 1337,!game.SinglePlayer() and R.CUserCmd.CommandNumber(cmd) or CurTime()) * (R.Entity.EntIndex(wep) % 30241)))
		local vecDir = Aimbot.ArcCWApplyRandomSpread(R.Angle.Forward(ang), disp)
		
		math.randomseed(math.Round(__G.util.SharedRandom(1, -1337, 1337, !game.SinglePlayer() and R.CUserCmd.CommandNumber(cmd) or CurTime()) * (R.Entity.EntIndex(wep) % 30241)))
		vecDir = Aimbot.ArcCWApplyRandomSpread(vecDir, spread)

		return ang + (ang - R.Vector.Angle( vecDir ))
	end

	if !cone then return ang end

	local seed = MD5.PseudoRandom( R.CUserCmd.CommandNumber( cmd ))

	-- setSeed( seed )

	local x, y = engineSpread[seed][1], engineSpread[seed][2]
	-- local x = randomFloat( -0.5, 0.5 ) + randomFloat( -0.5, 0.5 )
	-- local y = randomFloat( -0.5, 0.5 ) + randomFloat( -0.5, 0.5 )

	local forward, right, up = R.Angle.Forward( ang ), R.Angle.Right( ang ), R.Angle.Up( ang )
	local RetVec = forward - ( x * cone[1] * right ) - ( y * cone[2] * up )
	local spreadAngles =  R.Vector.Angle( RetVec )

	R.Angle.Normalize( spreadAngles )

	return spreadAngles
end